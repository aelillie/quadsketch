\section{Analysis}
\label{analysis}
%Our analysis of the paper and algorithm goes here
%From the course's intended learning outcomes (ILO):
%"Find, extract and explain results in the algorithms research literature relevant to a given problem"
%"Theoretically analyze the performance of a given algorithmic solution"
This section provides an analysis of properties of the \qs{} algorithm as introduced in \cite{wagner17}, which are deemed interesting and relevant for understanding the algorithm, and thus extend it with an improvement.

%TODO: Do we have more analysis?

\subsection{Why randomly shift hypercube?}
Randomly shifting a hypercube in each dimension is necessary for the \qs{} implementation to maintain guarantees on arbitrary datasets. We hope to obtain a cube in which data points near each other are shifted into the same leaves in the \qt{}. The shifting can have varying practical effects given the randomness of the shifting.
\\
\\
If the dataset is of a known format, randomly shifting it in each dimension could turn out to be less effective than taking a more specific approach. An example could be a dataset in which all the points are very close to each other. A large amount of the points might end up in the same leaves and as such defeat the purpose of using the \qt{} to begin with. Randomly shifting over these points will not be of any significant gain to the problem at hand. One approach could be to spread out the dataset in the sense of scaling the points given some constant to increase the distance between them and hereby obtain a \qt{} of a better quality. The original relative distance is preserved by remembering the scaling constant.

\subsection{Theorems}
The paper introduces three theorems, where \tm{1} is the main theorem covering the basic variant of \qs{}. \tm{2} covers a variant which focuses on minimizing the distortion between all points, and \tm{3} introduces a block variant of \tm{1} inspired by \cite{schmid9}.
\\
\tm{1} makes guarantees for a \qs{} variant, where “for each point, the distances from that point to all other points are preserved up to a factor of 1 $\pm$ $\epsilon$ with a constant probability”, whereas the latter “makes it possible to approximately preserve the distances between all pairs of points”. It seems like \tm{1} thus allows us to find distances between one single point and to all other points, but not the other way around, whereas with \tm{2} we can find the distance both from node 1 to node 2 and 3, but also from node 2 to node 3. This comes with a trade off, as with \tm{1} you are able to recover any points by decompressing the sketch, which is infeasible with \tm{2}, where \qs{} is recursively applied.
\\
\\
Due to some ambiguity between \tm{1} and \tm{2}, it is assumed that for \tm{1} the sketch is created from a single point, and from that point the distances to all other points are preserved up to a factor of 1 $\pm$ $\epsilon$. In \tm{2} however it is mentioned that the algorithm is applied recursively in order to preserve the distances between \textit{all} pairs with a high probability. 
\\
\\
The ambiguity arises due to several factors. Firstly it is stated in \tm{1} that \textit{foreach point} all distances from that point to all other points are preserved, which would entail that for any point it is possible to retrieve the approximate distance from that point to all others. In \tm{2} it is since highlighted that this theorem makes it possible to approximate the distance between \textit{all pairs of points}. This similarity between the two theorems makes it difficult to exactly analyze the differences between the two theorems. the stated running time for these two approaches are equal (possibly differing by a polylogarithmic factor), and because no actual probability or distortion guarentee is provided in \tm{2}. Without these bounds it becomes cumbersome to deduct the cost of the recursive process introduced in \tm{2} compared to the guarentees given in the other two theorems. Likewise does it not seem logical to introduce \tm{2} as it is not used later in the following theorem, which only builds on top of \tm{1} nor is it not used throughout the remainder of the paper.
%TODO: Properly review theorem section